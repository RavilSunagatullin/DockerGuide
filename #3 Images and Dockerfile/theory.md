# Образы Docker, Dockerfile и .dockerignore

## Для чего нужен этот модуль
На этом занятии мы учимся собирать собственные образы приложений и управлять их слоями. Чтобы сделать практику максимально приближенной к реальным задачам, основной пример посвящён PHP-сервису, который работает с базой данных MariaDB (совместима с MySQL) и сопровождается веб-интерфейсом администрирования phpMyAdmin. Дополнительно вы найдёте готовые конфигурации для Node.js, Go и Python в каталоге [`examples/`](./examples/) — это самостоятельные минимальные шаблоны без пошаговых пояснений.

После прохождения модуля вы сможете:
- описывать рабочую среду приложения в Dockerfile;
- использовать `.dockerignore`, чтобы не засорять образ лишними файлами;
- собирать и запускать связку из нескольких сервисов через `docker compose`;
- понимать, как Docker кеширует слои и когда кеш инвалидируется.

---

## 1. Минимальная теория по Dockerfile

1. **`FROM`** — задаёт базовый образ. Мы будем использовать `php:8.2-apache`, в котором уже предустановлены PHP и Apache HTTP Server.
2. **`WORKDIR`** — определяет рабочую директорию внутри образа, где будут выполняться последующие команды.
3. **`COPY`** — копирует файлы из контекста сборки в образ. Каждая инструкция `COPY` создаёт отдельный слой.
4. **`RUN`** — выполняет команду во время сборки. Полезно для установки зависимостей.
5. **`EXPOSE`** — описывает (для документации) какой порт слушает контейнер.
6. **`CMD`** — команда, которую Docker запускает при старте контейнера. Её легко переопределить аргументами `docker run`.
7. **`ENTRYPOINT`** — «жёсткая» точка входа; аргументы `docker run` добавляются к ней.

Каждая инструкция формирует новый слой. Если содержимое шага не меняется, Docker использует кеш. Поэтому выгодно отделять копирование зависимостей от копирования остального кода.

`.dockerignore` работает как `.gitignore`: перечисленные пути не попадут в контекст сборки, а значит не увеличат размер образа и не спровоцируют лишнее пересобирание слоёв.

---

## 2. Технологический стек лабораторной

| Компонент        | Роль в системе                               | Образ/версия                             |
|------------------|----------------------------------------------|------------------------------------------|
| PHP + Apache     | Основное веб-приложение                      | `php:8.2-apache`
| MariaDB (MySQL)  | Хранилище данных                             | `mariadb:11`                             |
| phpMyAdmin       | Веб-интерфейс для работы с базой данных      | `phpmyadmin/phpmyadmin:latest`

> Почему MariaDB? Это форк MySQL, полностью совместимый на уровне SQL и протокола подключения. Его проще запускать в Docker, но при желании можно заменить образ на `mysql:8`.

---

## 3. Структура проекта

Создаём рабочую директорию (например, `php-lab/`) и готовим такую структуру:

```
php-lab/
├── docker-compose.yml
├── .env                # настройки (опционально)
├── .dockerignore
└── php/
    ├── Dockerfile
    └── index.php
```

*В каталоге [`examples/php/`](./examples/php/) лежит готовая версия файлов, чтобы можно было свериться.*

---

## 4. Создаём `.dockerignore`

В корне проекта разместите файл `.dockerignore`:

```
.git
.env
vendor
node_modules
*.log
```

- `vendor` и `node_modules` оставлены на случай, если вы подключите PHP-зависимости через Composer или добавите фронтенд-сборку.
- `.env` не попадёт в образ, секреты останутся только на локальной машине.

---

## 5. Пишем Dockerfile для PHP-приложения

`php/Dockerfile`:

```Dockerfile
FROM php:8.2-apache

WORKDIR /var/www/html

RUN docker-php-ext-install mysqli

COPY index.php ./

EXPOSE 80
CMD ["apache2-foreground"]
```

* Раз базовый образ содержит Apache, нам не нужно устанавливать веб-сервер вручную.
* Команда `docker-php-ext-install mysqli` активирует расширение `mysqli`, необходимое для подключения к MariaDB/MySQL.
* Файл `index.php` копируется в стандартную директорию, из которой Apache отдаёт сайты.
* Команда `apache2-foreground` — правильный способ запустить Apache в режиме «всё в одном процессе», чтобы Docker отслеживал его жизнь.

Если в будущем понадобится Composer или расширения PHP, добавляйте инструкции `RUN docker-php-ext-install ...` или `COPY --from=composer:2 /usr/bin/composer /usr/bin/composer` с сохранением принципа раздельных слоёв.

---

## 6. Исходный код сервиса

`php/index.php` для проверки подключения к MariaDB:

```php
<?php
$host = getenv('DB_HOST') ?: 'db';
$port = getenv('DB_PORT') ?: '3306';
$dbname = getenv('DB_NAME') ?: 'app_db';
$user = getenv('DB_USER') ?: 'app_user';
$password = getenv('DB_PASSWORD') ?: 'secret';

$mysqli = @new mysqli($host, $user, $password, $dbname, (int) $port);

if ($mysqli->connect_errno) {
    echo 'Не удалось подключиться к MariaDB: ' . $mysqli->connect_error;
    exit;
}

echo 'Успешное подключение к MariaDB!';

$result = $mysqli->query('SELECT NOW() AS current_time');
if ($result) {
    $row = $result->fetch_assoc();
    echo '<br>Текущее время БД: ' . $row['current_time'];
    $result->free();
}

$mysqli->close();
```

Скрипт читает переменные окружения, устанавливает соединение и выводит результат простого запроса. Такой подход наглядно демонстрирует, как контейнеры обмениваются конфигурацией через переменные.

---

## 7. docker-compose.yml для всей связки

`docker-compose.yml`:

```yaml
version: "3.9"

services:
  app:
    build: ./php
    container_name: php-app
    ports:
      - "8080:80"
    environment:
      DB_HOST: db
      DB_PORT: 3306
      DB_NAME: app_db
      DB_USER: app_user
      DB_PASSWORD: secret
    depends_on:
      - db

  db:
    image: mariadb:11
    container_name: mariadb
    restart: always
    environment:
      MYSQL_DATABASE: app_db
      MYSQL_USER: app_user
      MYSQL_PASSWORD: secret
      MYSQL_ROOT_PASSWORD: root_secret
    volumes:
      - db_data:/var/lib/mysql
    ports:
      - "3306:3306"

  phpmyadmin:
    image: phpmyadmin/phpmyadmin:latest
    container_name: phpmyadmin
    restart: always
    environment:
      PMA_HOST: db
      PMA_PORT: 3306
      PMA_USER: app_user
      PMA_PASSWORD: secret
    ports:
      - "5050:80"
    depends_on:
      - db

volumes:
  db_data:
```

Ключевые моменты:
- PHP-приложение собирается из локального Dockerfile (`build: ./php`).
- `depends_on` гарантирует порядок запуска: БД стартует раньше, чем приложение и phpMyAdmin.
- Том `db_data` хранит данные MariaDB между перезапусками.
- Для phpMyAdmin открываем порт `5050`, чтобы не конфликтовать с приложением.

> **Замечание:** если вы хотите держать логины/пароли вне репозитория, создайте `.env` в корне и подключите его через `env_file`.

---

## 8. Сборка и запуск

1. Соберите и поднимите все сервисы:
   ```bash
   docker compose up --build
   ```
   Флаг `--build` принудительно пересобирает образ приложения, даже если кеш есть. На следующих итерациях можно опустить его, чтобы использовать кеш.

2. Проверьте работу:
   - `http://localhost:8080` — страница PHP должна вывести сообщение об успешном подключении и текущие время из базы.
   - `http://localhost:5050` — авторизуйтесь в phpMyAdmin (логин `app_user`, пароль `secret`) или войдите под root (`root` / `root_secret`).
     В разделе **Servers** увидите автоматически подключенную базу `app_db`.

3. Посмотрите логи и убедитесь, что сервисы стартовали без ошибок:
   ```bash
   docker compose logs app
   docker compose logs db
   docker compose logs phpmyadmin
   ```

4. Остановите связку после экспериментов:
   ```bash
   docker compose down
   ```
   Чтобы сохранить данные БД, оставьте том `db_data`. Добавьте `--volumes`, если хотите полностью очистить окружение.

---

## 9. Как работает кеш слоёв

Попробуйте изменить текст, который выводит `index.php`, и пересоберите образ командой `docker compose build app`. Docker пересоберёт только слои после команды `COPY index.php ./`. Если же вы поменяете базовый образ или добавите новую инструкцию `RUN`, пересборка затронет и нижележащие слои. Это упражнение помогает понять, почему важно группировать неизменные части (установка зависимостей) отдельно от часто меняющегося кода.

---

## 10. Что дальше

- Добавьте Composer и подключите реальные пакеты.
- Разверните миграции БД через тома или отдельный сервис.
- Настройте многослойную сборку (multi-stage build), чтобы собирать ассеты и копировать их в финальный образ.

Если потребуется вдохновение для других языков, загляните в директорию [`examples/`](./examples/). Там лежат минимальные конфигурации для Node.js, Go и Python, которые повторяют ту же логику Dockerfile и `.dockerignore`.
