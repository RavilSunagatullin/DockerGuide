# Диагностика и базовые best-practices

## Для чего нужен этот модуль
Финальный блок завершает курс и показывает, как поддерживать готовые контейнеры в рабочем состоянии. Мы продолжим работать с PHP-стеком из предыдущего модуля и сфокусируемся на двух практических задачах:

- быстро понять, что пошло не так, когда сервис не отвечает;
- избавиться от типичных ошибок, которые приводят к «битым» контейнерам или нестабильным окружениям.

Каждая секция содержит мини-практику: попробуйте повторить шаги на проекте `examples/php/` или своём приложении.

---

## 1. Диагностика контейнеров: от симптома к причине

### 1.1 Смотрим логи сервиса

1. Запустите стек: `docker compose up -d`.
2. Посмотрите поток логов только одного сервиса:

```bash
docker compose logs -f app
```

Если контейнер `app` падает с ошибкой PHP или базы данных, вы увидите трассировку прямо в терминале. Флаг `-f` показывает новые строки в реальном времени — удобно держать во втором окне, пока воспроизводите проблему.

> Совет: `docker compose logs --since=5m app` поможет вытащить только свежие сообщения, если в сервисе много шума.

### 1.2 Инспектируем контейнер

Команда `docker inspect` возвращает JSON с метаданными контейнера: переменные окружения, проброшенные тома, сетевые настройки.

```bash
docker inspect php-app | jq '.[0].Config.Env'
```

Сравните список переменных с тем, что указано в `docker-compose.yml`: несоответствие — частая причина «пустых» конфигов.

### 1.3 Проверяем использование ресурсов

Если контейнер стартует, но работает медленно, посмотрите статистику по CPU и памяти:

```bash
docker stats php-app db
```

Зависание PHP-FPM или перегруженная база часто заметны по всплеску памяти. Не забывайте про лимиты в `docker-compose.yml` — их отсутствие может привести к тому, что контейнер вытеснит остальные процессы.

### 1.4 Входим внутрь контейнера

Чтобы проверить, существует ли нужный файл, правильно ли монтируется том или какие пакеты доступны, зайдите в контейнер:

```bash
docker exec -it php-app sh
```

`sh` доступен практически во всех образах. Внутри используйте знакомые инструменты: `ls`, `cat`, `php -v`, `env`. Выход — `exit`.

### 1.5 Дополнительные инструменты

- `docker compose ps` — быстрый список статусов и коды выхода контейнеров.
- `docker compose top` — просмотр процессов внутри каждого сервиса без входа через `exec`.
- `docker events --since=1h` — хронология перезапусков и ошибок на уровне Docker Engine.

---

## 2. Уменьшаем размер образа

Крупные базовые образы замедляют CI/CD и требуют больше места в registry. Возьмём PHP-приложение и заменим `php:8.2-apache` на `php:8.2-apache-bullseye` или ещё легче — на `php:8.2-apache-bullseye-slim`. Для CLI-приложений с отдельным веб-сервером подойдёт `php:8.2-fpm-alpine`.

1. Отредактируйте `php/Dockerfile`:

```Dockerfile
FROM php:8.2-apache-bullseye-slim
...
```

2. Соберите образ:

```bash
docker compose build app
```

3. Сравните размеры до и после:

```bash
docker image ls 'php:8.2-apache*'
docker image ls php-lab_app
```

Обычно переход на slim экономит сотни мегабайт. Не забывайте добавить необходимые пакеты вручную (`apt-get update && apt-get install -y \
    libzip-dev ...`) — в лёгких базах по умолчанию меньше предустановленных зависимостей.

> Alpine хорош для CLI и микросервисов, но в связке с Apache чаще используют Debian/Ubuntu-слои из-за готовых модулей.

---

## 3. Запускаем контейнеры от non-root пользователя

Работа от `root` внутри контейнера облегчает жизнь, но создаёт риски: файлы на хосте получают права суперпользователя, а потенциальная уязвимость даёт полный доступ. В Dockerfile легко переключиться на обычного пользователя.

Добавьте в `php/Dockerfile`:

```Dockerfile
RUN useradd --create-home --shell /bin/bash app \
    && chown -R app:app /var/www/html
USER app
```

- `useradd --create-home` (для Debian/Ubuntu-образов) создаёт пользователя без пароля и домашнюю директорию. Для Alpine-аналогов используйте `adduser -D app`.
- `chown` гарантирует, что у пользователя достаточно прав на исходники.

После пересборки образа перезапустите контейнер и убедитесь:

```bash
docker exec -it php-app id
```

Вы должны увидеть `uid=1000(app) gid=1000(app)` или аналогичные значения. В CI стоит добавить проверку `docker inspect php-app | jq '.[0].Config.User'`.

---

## 4. Типичные проблемы и как их избегать

| Проблема | Как проявляется | Как диагностировать | Как исправить |
|---------|-----------------|---------------------|---------------|
| **Неправильные пути** | PHP не находит `config.php`, логи полны `No such file or directory`. | `docker exec` → `ls` нужной директории, проверьте `volumes` в compose-файле. | Уточните `WORKDIR`, используйте абсолютные пути, синхронизируйте структуру проекта на хосте и в контейнере. |
| **Ошибки конфигурации** | Приложение стартует с дефолтными настройками. | `docker inspect` → `Config.Env`, сравните с `.env`. | Храните значения в `.env`, проверяйте синтаксис (`docker compose config`). |
| **Права доступа** | `Permission denied` при записи логов или кешей. | `stat` внутри контейнера, проверка владельца тома. | Меняйте владельца через `chown`, запускайте контейнеры от отдельного пользователя. |
| **Локаль и часовой пояс** | Неправильное форматирование дат, некорректные сравнения строк. | `docker exec` → `locale`, `date`. | Установите пакеты локалей (`apt-get install locales`), задайте `TZ=Europe/Moscow`, смонтируйте `/etc/localtime` при необходимости. |
| **Несогласованные версии зависимостей** | Сборка падает после смены базового образа. | Просматривайте слой `RUN` в Dockerfile, проверяйте поддержку расширений. | Зафиксируйте версии пакетов, добавьте smoke-тесты (`docker compose run --rm app php -m`). |

---

## 5. Что ещё стоит иметь под рукой

- **Healthchecks.** Добавьте в `docker-compose.yml` секцию `healthcheck` с простым curl-запросом — Docker сам отметит контейнер как «здоровый» или нет.
- **Логирование в файл.** Если сервис генерирует много логов, перенаправьте их в stdout/stderr, чтобы не хранить файлы внутри контейнера.
- **Снапшоты данных.** Для баз данных держите регулярные дампы (`docker exec db mariadb-dump ...`). Это сильно упрощает диагностику после падений.
- **Автоматические lint-проверки Dockerfile.** Инструменты вроде `hadolint` заранее поймают ошибки и напомнят о best-practices.

Эти простые приёмы закрывают 80% реальных ситуаций в продакшене. Осваивайте диагностику на маленьких проектах — и в боевых условиях вы будете знать, какую команду запускать первой.
